## 算法与数据结构
### 进行补课(C语言中的指针，结构题，结构体指针，动态内存管理)
《高级语言程序设计》->程序抽象
《数据结构》->数据抽象
```mermaid
graph TD
    A[数据抽象] --> B[1.逻辑结构]
    A[数据抽象] --> C[2.存储结构]
    B --> D[1.1线性1对1]
    B --> E[1.2集合]
    B --> I[1.3一对多]
    B --> F[1.4图状结构]
    C --> G[2.1顺序]
    C --> H[2.2非顺序]
    H --> J[2.2.1链式存储结构]
```
课程类容
|线性表|
|栈和队列|
|字符串|
|数组和广义表|
|树和二叉数|
|图|
|查找|
|内部排序|
数据结构:
1.电话号码查询系统(字典)

2:图书馆的数目检索系统

3.计算级和人对弈

4.旅行商问题

5.井字棋对弈

6.田径赛的时间安排
### 基本概念
数据结构:研究数据的逻辑关系和物理关系,以及数据之间的相互关系,并在其上设计相关的算法
```mermaid
graph TD
     A[数据]-->B[数据对象]
     B -->C[数据元素]
     C-->D[数据相]
```
## 数据结构
### 第二章 线性表
#### 线性表的类型定义
n个顺序元素所组成的有限序列
第一个元素只有直接后继,中间元素有直接前趋和直接后趋,最后一个元素只有直接前继
2.1并集算法
$A = A \bigcup B$
算法
```c
viod union(List &La, List Lb){#注意这个地方有两个点，1在c中函数的变量引用的前面必须声明所引用的变量的类型，2此处的&La和Lb的引用,一个是引用传递(List &La) 一个是值传递(List Lb)引用传递可以在引用中更改原数据的变量，值传递不能在使用的过程中更改值的量，所进行运用的只是原始数据的一个备份
La_len = Listlength(La);
Lb_len = Listlength(Lb);
for(i = 1; i<=Lb_len;i++){
GetElem(Lb,i,e);
if(!LocateElem(La,e,equal))
Listinsert(La , ++La_len , e);#注意这个地方的插入只需要在表尾进行插入即可
}
}
```
以上的并集算法的算法复杂程度为O(n),因为在整个过程中只需要进行一次遍历Lb的循环
这个算法并不强调有序的概念，只要是LB中元素与LA中元素不同的元素，都会被加到LA中去
2.2归并有序算法(在并集的条件下再加入排序)
这个算法有一个严格的使用条件“本来的两个需要我们进行操作的表需要本来就是有序的”
$C = A \bigcup B$
归并有序算法要创造性的表，否则如果把表填充到A表中需要将后面的元素递归推动一位，这样十分的麻烦
算法思路
```c
void MergeList(List La,List Lb,List &Lc){
InitList(Lc);#由于我们要生成新的表，所以我们需要初始化以张新的表Lc
La_length = ListLength(La);
Lb_length = ListLength(Lb);
int i,j,k;
i=1;
j=1;
k=1;
int e,b;
while(i<=La_length&&j<=Lb_length){
GetElem(La,i,e);
GetElem(Lb,j,b);
if(e >= b){
ListInsert(Lc,k++,e);
i++;
}
else{
ListInsert(Lc,k++,b);
b++;
}
}
while(i<=La_length){
GetElem(La,i++,e);
ListInsert(Lc,k++,e);
}
while(j<=Lb_length){
GetElem(Lb,j++,b);
ListInsert(Lc,k++,b);
}
}
```
算法复杂程度为O(m+n);
这是顺序表算法中相当优秀的编码了
必须要记住条件为“所操作的两个表有着相同的递增或者递减的顺序表示”
#### 线性表的顺序表示和实现
数组也是循序表
对InitList的解析
```c
#define LIST_INIT_SIZE 100
#define LISTINCREMENT 10
typedef struct{
ElemType *elem;
int length;
int listsize;
}Sqlist;
```
把线性表的结点按逻辑顺序依次放在一组地址连续的储存单元内(顺序表)
$$LOC(a_(i+1) = LOC(a_(i) + I)$$
$$LOC(a_(i)) = LOCa_(1) + (i - 1)* I$$
## 结构初始化(创建顺序表)
```C++
Status Initlist_Sq(Sqlist &L){
L.elem = (ElemType *)malloc(LIST_INIT_SIZE*sizeof(ElemType)); #此处的ElemType指的是int , float这类的数据类型
#之所以要用ElemType是因为这不是完整代码，在全代码中，应该有“typedefine int ElemType”这类的代码，这样可以让这个代码之后的所有ElemType都是int，这样的好处是方便代码的优化的多样调用
if(!L.elem) exit(OVERFLOW);#在编程中，exit 是一个用于终止当前程序运行的函数（或语句），其核心作用是立即结束程序的执行，并返回一个状态码给操作系统。
L.length = 0;
L.listsize = LISt_INIT_SIZE;
return ok;
}
```
以上代码只是创建了一个空的顺序表(在c++中这串代码可以直接调用：InitList_Sq(L))
```c
Status InitList-Sq(SqList *L){
L->elem = (ElemType *)malloc(LIST_INIT_SIZE*sizeof(ElemType));
if(!L->elem) exit(OVERFLOW);
L->length = 0;
L->listsize = LIST_INIT_SIZE;
return OK;
}
```
以上代码是c中创建空顺序列表的代码(调用示例为：InitList_Sq(&La))
## 顺序表的插入和删除
顺序表的插入和删除都需要将操作元素之后的元素进行左移或者右移
### 插入
```c++
Status ListInsert_Sq(SqList &L, int i,ElemType e){
if(i<1||i>L.length+1) return ERROR;{#注意这个地方的i的限制可以取到L.length+1
newbase = (ElemType *)realloc(L.elem,(L.listsize+LISTINCREMENT)*sizeof(ElemType));
if(!newbase) exit(OVERFLOW);
L.elem = newbase; L.listsize += LISTINCREMENT;
}
ElemType *p;
p = &(L.elem[i-1]);
for(p = &(L.elem[L.length - 1]);p>=q;--p)
*(p + 1) = *p;
*q = e; ++L.length;
return OK;
}
```
算法复杂度为O(n)
c的源代码只是把Sqlist &L改成Sqlist *L，数据操作从方法操作(L.elem)改成指针操作(L->elem)
### 删除
```c++
Status ListDelet_Sq(Sqlist &L,int i,ELemType &e){
if((i<1)||(i>l.length)) return ERROR;
p = &(l.elem[i-1]);
q = L.elem + L.length - 1;#这个地方要理解L.elem表示的是L顺序表的基址(基址为L.elem[0]的地址)
for(++p;p<=q;++p){
*(p-1) = *p;
--L.length;
}
return OK;
}
```
算法复杂程度为O(n);
## 顺序表的查找
```c++
int LocateElem_Sq(Sqlist L,ElemType e,Status(*compare)(ElemType,ElemType)){
#注意此处我们对L表做的是值传递，而不是引用传递
i=1;
p = L.elem;
while(i<=L.length && !(*compare)(*(p++),e)) ++i;
if(i<=L.length) return i;
else return 0;
}
```
算法复杂程度为O(n)
#### 线性表的链式表示和实现
按照链接方式来分类
1.线性链表
2.循环链表
3.双向链表
按实现方式给分类
1.动态链表
2.静态链表
##### 线性链表
链表中节点的逻辑顺序和物理顺序不一定相同
线性链表中有一个头节点
这个节点可以空也可以储存该链表的长度
线性链表由节点构成，每个节点包含数据域和指针域
输出说明如下
```c
(*p) = LNode #*p 得到的是 p 所指向的整个节点（结构体变量），包含该节点的 data（数据域）和 next（指针域）两个成员。
p->data ((*p).data)#是访问了p节点的数据域
p->next ((*p).next)#是访问了p节点的指针域
```
## 创建线性链表
```c
typedef struct LNode{
ElemType data;
struct LNode *next;
}LNode,*LinkList;
LNode *p;
LinkList head;
```
```c
#线性链表(单链表)操作一览
GetElem_L(L,i,e)
ListInsert_L(&L,i,e)
ListDelet_L(&L,i,e)
ClearList_L(&L)#重置线性表为空表
CreateList_L(&L,n)#生成含有n个元素的链表
#以上除了第一个操作外，其他操作都需要对链表本身进行更改，所以是使用的引用取值
```
在数据结构中，随机存储结构（Random Access Structure） 是一种能通过元素的 “位置标识”（如索引）直接访问任意元素，且访问时间不随元素位置或数据量变化的存储方式。其核心特征是 “直接定位、常数时间访问”，区别于需按顺序遍历的 “顺序存储结构”（如链表）。
## 链表查找运算(GetElem_L(LinkList L,int i,ElemType &e)
不需要对L链表本身进行更改，所以是值传递，而对e需要改变其本身的值所以是引用传递(这些区别只在c++中有)
```c++
Status GetElem_L(LinkList L,int i,ElemType &e)
{
int j;
P = L->next;j = 1;
while(p && j<1){
P = P->next;j++;
}
if(!p || j>i)return ERROR;
e = p->data;
return OK;
}
p = (LNode*)malloc(sizeof(LNode));#p为动态变量，它是通过这个标准函数生成的
```
时间复杂程度为O(n)
## 链表的插入运算
```c++
Status LinkInsert_L(LinkList &L,int i,ElemType e){
p=L;j =0;
while(p&&j<i-1){
p = p->next;++j;
}#要在j处插入数，指针要先指到i处
h = (NLode*)malloc(sizeof(NLode));
h->data = e;
h->next = p->next;#需要注意此处的更改指针的顺序，由于要使用p->next所以一开始p->next不能被变动
p-next = h;
return OK;
}
```
时间复杂程度为O(n)
## 链表的删除运算
```c++
Status ListDelete_L(NLode &L,int i,ElemType &e){
p = L;
int j=0;
while(p&&j<i-1){
p = p->next;j++;
}
s = p->next;
p->next = s->next;#注意删除顺序
e = s->data;
free(s);
return OK;
}
```
## 建立单链表
1.头插法
这个方法有个弊端，就是生成的链表中的节点的次序和输入的顺序相反。
```c++
Status CreateList_L(ListLink &L,int n){
L = (LinkList)malloc(sizeof(LNode));
L->next = NULL;
for(i = n; i>0 ;--i){
 p = (LinkList)malloc(sizeof(NLode))
p->next = L->next;
scanf(&p->data);
L->next = p;
}
}
```
时间复杂度为O(n)
2.尾插法
我们希望生成链表中的节点的次序和输入的相同，则尾插法可以满足我们的需求
这个方法最大的不同是这个链表没有头节点，取而代之的是尾节点
```c++
Status CreateList_L(LinkList &L){
char ch;LNode *P, *r;
L=NULL; r=NULL;
while((ch = getchar())!='\n'{
p = (LNode *)malloc(sizeof(LNode));
p->data = ch;
if(L==NULL){L=p;r=p;}
else(r->next = p;r=p;)
}
if(r!=NULL){
r->next = NULL;
return OK;#最后补上空的尾指针
}
}
```
时间复杂程度为O(n)
## 有序链表的合并
思路和顺序链表的相同
##### 静态链表
可以用一维数组来描述链表(存储空间连续，存储逻辑不连续)
有头指针，指向链表第一个数据的数组下标，数据节点由数据域和游标域组成，最后一个数据节点的游标域指向0
```c++
#define MAXSIZE 1000 //链表的最大长度
typedef struct{
ElemType date;
int cur;
}component,SLinkList[MAXSIZE];
```
## 静态链表的查找--按照内容查找
```c++
int LocateElem_SL(SLinkList L,int s,ElemType e){
#s为头指针
i = L[s].cur;
while (i && L[i].data!=e)
i=L[i].cur;
return i;
}
```
时间复杂程度O(n)
## 初始化静态链表
```c++
void InitSpace_SL(SlinkList &space){
for(i = 0;i<MAXSIZE-1;++i)#0处不储存信息，开始遍历过一遍就跳过
space[i].cur = i+1;
space[MAXSIZE - 1].cur = 0;
}
```
静态链表实现时用户必须自己实现free和malloc两个函数
## 静态链表实现运算$(A-B)\bigcup(B-A)$
```c++
void difference(SLinkList &space,int &S){
InitSpace_SL(space);
S = Malloc_SL(space);
r = S;
scanf(m,n);
for(j = 1;j<=m;++j){
i = Malloc_SL(space);
scanf(space[i].data);
space[r].cur = i;r = i;
}
space[r].cur = 0;
for(j = 1;j<=n;++j){
scanf(b);
p = S;k = space[S].cur;
while(k! = space[r].cur && space[k].data!=b){
p = k;k = space[k].cur;
}
if( k == space[r].cur){
i = Malloc_SL(space);
space[i].data = b;
space[i].cur = space[r].cur;
space[r].cur = i;
}
else
space[p].cur = space[k].cur
Free_SL(space,k);
if(r == k)
r = p;
}
}
```
##### 动态链表
##### 循环列表
线性链表的尾指针指向头节点则为循环链表
##### 双向链表
线性链表的每一个节点不仅有指向下一个元素的指针还有指向上一个节点的指针
##### 双向循环链表
在双向链表的基础上头节点的头指针指向最后一个节点，尾节点的尾指针指向头节点

注意双向链表或者双向循环链表在插入或者删除的时候节点指针的删除顺序
#### 一元多项式的表示和相加
### 栈
栈是限制在表的一端机进行插入和删除运算的线性表，通常称插入，删除的这一端为栈顶，另一端为栈底
#### 栈的基本运算
构建栈(InitStack(&S))
判栈空(StackEmpty(s))
判栈满(StackFull(s))
插入(Push(&S,e))
1.入栈
2.进栈
3.压栈
删除(Pop(&S,&e))
1.出栈
2.弹栈
取栈顶(GetTop(S,&e))
### 顺序栈
由于栈是运算受限的线性表，因此线性表的存储结构对栈也适应

栈的顺序存储结构为顺序栈，由于其受限制于线性表，所以它可以用数组来表示顺序栈
## 顺序栈的类型定义
```c++
#define STACK_INIT_SIZE 100;
#define STACKINCREMENT 10;
typedef struct{
SElemType *base;
SElemType *top;
int stacksize;
}SqStack;
```
## 初始化栈
```c++
Status InitStack(SqStack &S){
S.base = (ElemType*)malloc(STACK_INIT_SIZE*sizeof(ElemType));
if(!S.bace) exit (OVERFLOW);
S.top = S.bace;
S.stacksize = STACK_INIT_SIZE;
return OK;
}
```
## 退栈
```c++
Status Pop(SqStack &S,SElemType &e){
if(S.top == S.base)return ERROR;
e = *--S.top;
return OK;
}
```
## 入栈
```c++
Stacus Push(SqStack &S,SElemType e){
if(S.top - S.bace >= S.stacksize){
S.base = (ElemType*)realloc(S.Bace,(S.stacksize + STACKINCREMENT) * sizeof(ElemType));#这个表示追加后的内存为这么多
if(!S.base) exit(OVERFLOW);
S.top = S.base + S.stacksize;
S.stacksize += STACKINCREMENT;
}
*S.top++=e;
return OK;
}
```
## 取栈顶(GetTop)
```c++
Status GetTop(SqStack S,SEleinType &e){
if(S.top == S.base)exit(ERROR);
e = *(S.top-1);
return OK;
}
```
### 链栈
### 栈的运用
1.数制转换
```c++
void conversion(){
initstack(s);
scanf('%d',n);
while(n){
push(s,n%8);
n = n/8;
}
while(!Stackempty(s)){
pop(s,e);
printf('%d',e);
}
}
```
2.括号匹配
```c++
Status matching(string& exp){
int state, i= 1, 1;
while(i<=Length(exp)&&state){
switch of exp[i]{case '(':{Push(S,exp[i]);i++;break;}
case')':{if(NOT StackEmpty(S)&&GetTop(S)='('){Pop(S,e);i++;}
    else{state = 0;}
break;}
}
}
if(StackEmpty(S)&&state)return OK;
```
3.行编程
```c++
while(ch!=EOF){
while(ch!=EOF&&ch!='\n'){
switch(ch){
case'#':Pop(S,c);break;
case'@':ClearStack(S);break;
default:Push(S,ch);break;
}
ch = getchar();
}
ClearStack(S);
if(ch!=EOF)ch = getchar();
}
```
4.迷宫求解
路径信息的保存
```c++
typedef struct{
int ord;#通道块在路径上的序号
PosType seat;#通道块在迷宫中的坐标
int di;从此通道块走向下下一个通道块的方向
}SELem Type;
```
迷宫求解的简单算法
```c++
Status MazePath(MazeType maze,PosType start,PosType end)
InitStack(S);curpos = start;
curstep = 1;
do{
if(Pass(curpos)){
Footprint(curpos);
e = (curstep,curpos,1);
Push(S,e);
if(curpos == end)return(TRUE);
curpos = NextPos(curpos,1);
curstep++;
}
else{
if(!StackEmpty(S)){
Pop(S,e);
while(e.di == 4&&!StackEmpty(S)){
MarkPrint(e.seat);Pop(S,e);
}
if(e.di < 4){
e.di++;Push(S,e);
curpos = NextPos(e.seat,e.di);
}
}
}
}
while(!StackEmpty(S));
return(FALSE);
}
```
5.表达式求值(运算符优先关系)
```C++
OperandType EvaluateExpression(){
InitStack(OPTR);push(OPTR,'#');
InitStack(OPTR);c = getchar();
while(c! = '#'||GetTop(OPTR)! = '#'){
if(!ln(c,OP)){Push(OPND,c);c = getchar();}
else
switch(Precede(GetTop(OPTR),c)){
case'<':Push(OPTR,c);c = getchar();break;
case'=':Pop(OPTR,x);c = getchar();break;
case'>':Pop(OPTR,theta);Pop(OPND,b);
Pop(OPND,a);Push(OPND,Operate(a,theta,b));break
}
}
return GetTop(OPND);
}
```
### 栈与递归
### 队列
队列(Queue)也是一种受限制的线性表，他只允许在表的一端进行插入，而在另一端进行删除(出队列)。允许删除的一端叫做队头(front)，允许插入的另一端叫做队尾(rear)
允许的运算为先进后出的线性表
抽象数据类型的队列定义
#### 队列的基本操作
```c++
InitQueue(&Q)    DestroyQueue(&Q)
QueueEmpty(Q)    QueueLength(Q)
GetHead(Q,&e)    ClearQueue(&Q)
EnQueue(&Q,e)    DeQueue(&Q,&e)
QueueTravers(Q,visit())
```
### 循环队列
为了克服一般队列储存空间利用率较少的情况，我们可以采用循环队列来对之前用过但是被删除的队列元素所占据的空间进行重复利用
```c++
# define MAXQSIZE 100
typedef struct{
QElemType *base;
int front;#头指针，若队列不空，指向队列头元素
int rear;#尾指针，若队列不空，指向队尾元素的下一个元素
}SqQueue;
```
```c++
#创建一个空的队列Q
Status InitQueue(SqQueue &Q)
{
Q.base = (ElemType*)malloc(MAXSIZE * sizeof(ElemType));
if(!Q.base)exit(OVERFLOW);
Q.front = Q.rear = 0;
return OK;
}
```
插入元素e为Q的新的队尾元素
```c++
if((Q.rear + 1)% MAXSIZE == Q.front)
return ERROR;
Q.base[Q.rear] = e;
Q.rear = (Q.rear + 1)%MAXSIZE;#这个地方体现了循环
return OK;
```
```c++
在队列中出一个元素
Status DeQueue(SqQueue &Q,ElemType &e){
if(Q.front == Q.rear)return ERROR;
e = Q.base[Q.front];#不用真正删除，只是将Q.front移开之后Q.rear就可以更改这个地方的数据了
Q.front = (Q.front + 1)% MAXSIZE;
return OK;
}
```
```c++
#返回Q的元素的个数,即队列的长度
int QueueLength(SqQueue Q)
{
return(Q.rear - Q.front + MAXSIZE)%MAXSZIE;
}
```
### 链队列
先进先出
```C++
typedef struct QNode{#节点类
QElemType data;
struct QNode *next;
}QNode;
typedef struct{#链队列类型
QNode *front;
QNode *rear;
}LinkQueue;
```
```c++
Status InitQueue(LinkQueue &Q){
#构造一个空的链队列
Q.front = Q.rear = (QNode *)malloc(sizeof(QNode));
if(!Q.front)exit(OVERFLOW);
Q.front->next = NULL;
return OK;
}
```
```c++
#销毁队列
Status DestroyQueue(LinkQueue &Q){
whlie(Q.front){
Q.rear = Q.front->next;
free(Q.front);
Q.front = Q.rear;
}
return OK;
}
```
```c++
#插入元素e为Q的新的队尾元素
Status EnQueue(LinkQueue &Q,QElemType e){
p = (QueuePtr)malloc(sizeof(QNode));
if(!p)exit(OVERFLOW);
p->data = e;p->next = NULL;
Q.rear->next = p;Q.rear = p;
return OK;
}
```
```c++
Status DeQueue(LinkQueue &Q,QElemType &e){
if(Q.front == Q.rear)return ERROR;
p = Q.front->next; e = p->data;
Q.front->next = p->next;
if(Q.rear == p)
Q.rear = Q.front;
free(p);
return OK;
}
```
### 串
串是0个或者多个字符(同等位置下，线性表的组成元素为数据元素，这个点为主要的区别)组成的有限序列

空串：串的长度为0的串为空串，不包含任何字符

空白串：由一个或者多个空格组成的串为空白串

### 串的基本概念
串中任意个连续的字符组成的子序列称为该串的子串,包含子串的串相应的称为主串
```c++
#串的基本操作
StrAssign(&T,chars)
DestroyString(&S)
StrCopy(&T,S)
StrLength(S)
StrCompare(S,T)
Concat(&T,S1,S2)
StrEmpty(S)
SubString(&S)
Index(S,T,pos)
Replace(&S,T,V)
StrInsert(&S,pos,T)
StrDelete(&S,pos,len)
```
#### 串的定义
串是0个或者多个字符(同等位置下，线性表的组成元素为数据元素，这个点为主要的区别)组成的有限序列
#### 串与线性表的区别
串的逻辑结构与线性表极为相似,区别仅仅在于串的数据对象约束为字符集

然而串的基本操作和线性表之间由很大的差别
1.线性表大多以单个元素为操作对象，而串通常以串的整体为操作对象
#### 串的表示和实现
##### 串的定长顺序存表示
##### 串的堆分配存储表示
##### 串的链式存储结构
```c++
typedef struct node{
char data;#注意这个地方的存储的信息为char
struct node *next;
}LString;
```
#### 串的模式匹配算法
基本思想
从主串S的第pos个字符起和模式T的第一个字符比较，若相等，则继续逐个比较后继字符，否则从下一个字符起重新和模式T的字符比较。一次类推，直到匹配成功
否则匹配失败
```c++
int Index(SString S,SString T,int pos){
#返回子串T在主串S中第pos个字符之后的位置.若不在，则返回数为0.其中T非空
1<= pos <=StrLength(S)
i = pos; j = 1;
while(i<=S[0]&&j<=T[0]){
if(S[i]==T[j]){++i;++j;}
else{i= i-j +2;j=1;}
}
if(j > T[0])return i-T[0];
else return 0;
}
```
##### kmp算法
改进的模式匹配算法
定义模式串的next函数：若令next[j] = k,则next[j]表明单模式串中的第j个字符与主串的第i个字符失配时，在模式串中需重新和主串中该字符进行比较的字符的位置
$next[j] = case(1) = 0 when j = 1;
           case(2) = Max{k|1<k<j且'p_1 p_2...p_{k-1}' = 'p_{j-k+1...p_{j-1}}}
           else 1$
           这个next函数三个情况都难以记忆，所以我们必须都牢记
next函数本身也被称为失效函数，其取值取决于模式串本身而和相匹配的主串无关
---与i无关
```c++
int Index_KMP(SString S,SString T,int pos){
i = pos;j = 1;
while(i<= S[0]&&j<=T[0]){
if(j == 0||S[i]==T[j]){++i;++j;}
else j = next[j];
}
if(j>T[0])return i-T[0];
else return 0;
}
```
next函数
```c++
void get_next(SString &T,int &next[])
{
i = 1;next[1] = 0;j = 0;
while(i<T[0]){
if(j == 0||T[i]==T[j])
{++i;++j;next[i] = j;}
else j = next[j];
}
}
```
#### 串的应用举例
1.文本编辑
2.信息检索
### 矩阵数据存储(多维数据存储)
数组和广义表可看成是一种特殊的线性表，其特殊在于，表中的数组元素本身也是一种线性表
#### c语言中的二位数组可以定义为一维数组类型的一维数组类型
```c++
typedef Elemtype Array2[m][n];
#等价于
typedef Elemtype Array1[n];
typedef Array1 Array2[m];
```
所以n维数组就可以定义为n-1维数组的一维数组类型

数组一旦被定义，它的维数和维界就不再改变，因此除了结构的初始化和销毁之外，数组只有存取元素和修改元素值的操作
#### 数组的抽象数据定义
```c++
InitArray(&A,n,bound1,...,boundn);# 初始化一个n维数组
Destroy(A,&e,index1,...,indexn);# 销毁一个数组
Assign(&A,e,index1,...,indexn);# 将e的值赋给所指定的A的元素，返回ok
Value(A,&e,index1,...,indexn);# 将A的某个值赋给e
```
#### 数组的顺序表示和实现
行优先顺序
列优先顺序
对于行优先级或者列优先级，可以将数组元素的存放地址表示为其下标的线性函数
因此，数组的任意元素可以在相同的时间内存取

所以顺序存储结构是一个随机存取结构
#### 矩阵的压缩存储
为了节省存储空间，我们可以对有大量相同元素的矩阵进行压缩存储，即为多个相同的非零元素只分配一个存储空间，对0元素不分配空间
#### 特殊矩阵
##### 对称矩阵
让每两个相同的元素共享一个空间，这样，能节约近一半的存储空间
##### 三角矩阵
三角矩阵中重复的c个元素可以共享一个存储空间，其余元素正好有n(n+1)/2个，因此，三角矩阵可压缩存储到向量sa[0...n(n+1)/2]中，c存储到最后一个分量中
##### 对角矩阵
对角矩阵中，所有的非零元素集中在以对角线为中心的带状区域中，即除了主对角线和主对角线相邻两侧的若干条对角线上的元素之外，其余元素皆为零

可按照某个原则将其压缩存储到一维数组上

```
上述的各种特殊矩阵，其非零元素的分布都是有规律的，因此总能找到一种方法将他们压缩存储到一个向量中，并且一般都能找到矩阵的元素与该向量的对应关系，通过这个关系，依能对矩阵的元素进行随机存取
```
#### 稀疏矩阵
在矩阵A中，有t个非零元素，令$\sigma = t/(m*n)$则称$\sigma$为稀疏因子
通常认为$\sigma<=0.05$时称之为稀疏矩阵

所以我们记住它的非零元素的时候还要记住它的位置(i,j)

一个三元组唯一确定了矩阵A的一个非零元，因此，稀疏矩阵可由表示非零元的三元组及其行列数唯一确定
```c++
CreateMatrix(&M);
DestroySMatrix(&M);
PrintSMatrix(M);
CopySMatrix(M,&T);
AddSMatrix(M,N,&Q);
SubtMatrix(M,N,&Q);
MultSMatrix(M,N,&Q);
TransposeSMatrix(M,&T);
```
稀疏矩阵的三种压缩存储方法
1.三元组顺序表
2.行逻辑链接的顺序表
3.十字链表

```c++
# 三元组顺序表
define MAXSIZE 12500
typedef struct{
int i,j;
ElemType e;
}Triple
typedef struct{
Triple data[MAXSIZE + 1];#data[0]未用
int mu,nu,tu;#矩阵的行数，列数和非零元个数
}TSMatrix;
```
### 树
## 图
### 图的定义和术语
图是由一个顶点集V和一个孤点R构成的数据结构
```
Graph = (V, R)
```
<v,w>表示从v到w的一条弧,并称v为弧头,w为弧尾
谓词$P(v,w)$定义了弧<v,w>的意义或信息

#### 连通性术语(无向图的连通性)
路径:在无向图$G=(V,{E})$中由顶点v至v'的顶点序列

例如$(0,1,2,0,1,3)$

回路或环:第一个顶点和最后一个顶点相同的路径

简单回路或简单环:除第一个顶点和最后一个顶点之外,其余顶点不重复出现的回路

连通:顶点v至v'之间有路径存在

连通图:无向图图G的任意两点之间都是连通的,则G为连通图

连通分量:若无向图为非连通图,则图中的各个连通子图称做此图的连通分量
#### 连通性的术语(有向图的连通性)
强连通图:有向图图G的任意两点之间都是连通的,则称G为强连通图

强连通子图:极大连通子图

#### 生成树的术语
生成树:极小连通子图,包含图的所有n个结点,但只含图的n-1条边,在生成树中添加一条边之后必定会形成回路或者环

性质:在任意无向图中,若有n个顶点和小于n-1条边,则必定是连通图,若有多于n-1条边,则必定有环
#### 图的其他术语
完全图:有$n(n-1)/2$条边的无向图.其中n为节点个数

有向完全图:有$n(n-1)$条边的有向图

假若顶点v和顶点w之间存在一条边,则称顶点v和w互为邻接点,边(v，w)和顶点v,w向关联

边的度:和顶点v关联的边的数目定义为顶点的度,而有向图就会区分有出度和入度
### 图的数据定义和基本操作
#### 图的数据定义
```c++
ADT Graph{
数据对象V;V是具有相同特性的数据元素的集合,称为顶点集
数据关系R;R={VR}
VR={<v,w>|v,w\in V且P(v,w),<v,w>为有向的}
}
```
#### 图的基本操作
结构的建立和销毁 GreatGraph(&G,V,VR); DestroyGraph(&G);

对顶点的访问操作 LocateVex(G,u); GetVex(G,v); PutVex(&G,v,value);

对邻接点的操作 FirstAdjVex(G,v); NextAdjVex(G,v,w);

插入或者删除结点 InsertVex(&G,v); DeleteVex(&G,v);

插入或者删除弧 InsertArc(&G,v,w); DeleteArc(&G,v,w);

遍历 DFSTraverse(G,Visit 
()); BFSTraverse(G,Visit());
### 图的存储结构
线性表,栈,队列,矩阵等均有两类不同的存储结构,它们分别由顺序映像和链式映像得到

广义表,树,图等没有顺序映像的存储结构,但是可以借助数组这种数据类型来表示元素之间的关系

####图最常用的四种存储形式
1.数组:邻接矩阵和加权邻接矩阵(labeled adjacency matrix)

2.邻接表

3.十字链表(用于有向图,查询进入结点和离开结点的边容易)

4.邻接多重表(用于无向图,边表中的结点只需要存放一次,节约内存)
##### 数组(邻接矩阵)存储表示
```
数组表示法的特点

优点.容易实现图的各种基本操作
1.查找顶点,如LocateVex(G,C)
2.判断顶点之间是否有边,仅消耗O(1)
3.找顶点的邻接点,如FirstAdjVex(G,D),NextAdjVex(G,D,B)

缺点 即使边数<<n^{2},也需要占用O(n^{2})的存储单元;
读入数据需要耗费O(n^2)时间
```
1.无权的有向图的邻接矩阵
A[i,i] = 0;出度为i行之和,入度为j列之和

2.有权值的无向图的邻接矩阵(对称图,可以使用压缩存储的方法只存储上三角形)

3.有向图的加权邻接矩阵

设有向图具有n个结点,则用n行n列的矩阵A表示该有向图;并且A[i,j] = a,如果i至j有一条有向边且它的权值为a.

优点:判断任意两点之间是否有边方便,仅消耗O(1)时间

缺点:空间占用O(n2),太多
#### 代码(先学逻辑再学代码)
图的邻接矩阵存储表示
```c++
typedef cnum{DG,DN,UDG,UDN}GraphKind;
typedef struct ArcCell{
VRType adj:
InfoType *info;
}ArcCell,AdjMatrix[MAX_VERTEX_NUM][MAX_VERTEX_NUM]
```
```c++
#图的邻接矩阵存储表示
typedef struct{
VertexType vexs[MAX_VERTEX_NUM];
AdjMatrix arcs;
int vexnum,arcnum;
GraphKind kind;
}MGraph;
```
```c++
#构建无向图
Status CreateUDN(MGraph &G){
scanf(&G.vexnum,&G.arcnum,&IncInfo);
for(i = 0;i<G.vexnum;++i) scanf(&G.vexs[i]);
for(i = 0;i<G.vexnum;++i)
   for(j = 0;j<G.vexnum;++i)
      G.arcs[i][j] = {INFINITY,NULL};
for(k = 0;k<G.arcnum;++k){
scanf(&v1,&v2,&w);
i = LocateVex(G,v1);j = LocateVex(G,v2);
}
}
```
### 图的存储结构
### 图的遍历
### 图的连通性问题
### 有向无环图及其运用
### 最短路径
# C++ 数据结构基础操作速查表

## 顺序表 (std::vector)
- **头文件**: `#include <vector>`
- **定义格式**: `std::vector<数据类型> 变量名;`
- **基础操作**:
  - 插入: `push_back(值)` (尾部插入), `insert(迭代器位置, 值)` (指定位置插入)
  - 删除: `pop_back()` (尾部删除), `erase(迭代器位置)` (指定位置删除)
  - 访问: `[索引]`, `at(索引)`, `front()` (首元素), `back()` (尾元素)
  - 其他: `size()` (元素个数), `empty()` (判空), `clear()` (清空)

## 链表 (std::list)
- **头文件**: `#include <list>`
- **定义格式**: `std::list<数据类型> 变量名;`
- **基础操作**:
  - 插入: `push_back(值)` (尾部插入), `push_front(值)` (头部插入), `insert(迭代器位置, 值)` (指定位置插入)
  - 删除: `pop_back()` (尾部删除), `pop_front()` (头部删除), `erase(迭代器位置)` (指定位置删除)
  - 访问: `front()` (首元素), `back()` (尾元素)
  - 其他: `size()` (元素个数), `empty()` (判空), `clear()` (清空), `sort()` (排序)

## 栈 (std::stack)
- **头文件**: `#include <stack>`
- **定义格式**: `std::stack<数据类型> 变量名;`
- **基础操作**:
  - 入栈: `push(值)`
  - 出栈: `pop()` (无返回值)
  - 访问栈顶: `top()`
  - 其他: `size()` (元素个数), `empty()` (判空)

## 队列 (std::queue)
- **头文件**: `#include <queue>`
- **定义格式**: `std::queue<数据类型> 变量名;`
- **基础操作**:
  - 入队: `push(值)`
  - 出队: `pop()` (无返回值)
  - 访问: `front()` (队头元素), `back()` (队尾元素)
  - 其他: `size()` (元素个数), `empty()` (判空)


